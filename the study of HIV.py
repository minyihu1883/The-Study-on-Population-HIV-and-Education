# -*- coding: utf-8 -*-
"""CIS545 Final Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BFT8ooRc86L9NMYYzB4Wf4MwJj9ti0Eu

The link of our blog: https://medium.com/@peihanli/the-study-on-population-hiv-and-education-3dbe5128dc65

# Load Packages
"""

!pip install geopandas
!pip install mapclassify
!pip install fbprophet
!pip install statsmodels
!pip install pycountry-convert
!pip install statsmodels

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
import plotly.graph_objects as gp
from queue import PriorityQueue
import geopandas
from geopandas import GeoDataFrame
import mapclassify
from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tsa.stattools import adfuller
from pandas.plotting import autocorrelation_plot
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
import statsmodels.api as sm
import fbprophet
from fbprophet import Prophet
import pycountry_convert as pc
np.random.seed(0)
import seaborn as sns; sns.set_theme()
from sklearn.impute import KNNImputer 
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder
from sklearn import preprocessing
from google_drive_downloader import GoogleDriveDownloader as gdd

"""## Read Raw Data"""

#making sure we're using the same dataset
#Download data
from google_drive_downloader import GoogleDriveDownloader as gdd
# https://drive.google.com/file/d/1K6EenD5rYjZuvMwH-5g10GlbXPIsYI_n/view?usp=sharing
gdd.download_file_from_google_drive(file_id='1K6EenD5rYjZuvMwH-5g10GlbXPIsYI_n',
                                    dest_path='/content/data.csv')

# https://drive.google.com/file/d/11z2X-yajVr8zL6uIHrudEZDFNqDNRei0/view?usp=sharing
gdd.download_file_from_google_drive(file_id='11z2X-yajVr8zL6uIHrudEZDFNqDNRei0',
                                    dest_path='/content/transposed_data.csv')

## read raw data
raw_data = pd.read_csv('data.csv')
raw_data.drop(columns = 'Unnamed: 60', inplace = True)

## Let columns be the features and add a column named year
simple_df = raw_data.drop(columns = ['Country Code', 'Indicator Code'] )
ls_country = raw_data['Country Name'].unique()
transposed_data = pd.DataFrame()


for country in ls_country:
    partial_data = simple_df[simple_df['Country Name'] == country]
    partial_data.drop(columns = 'Country Name', inplace = True)
    t_data = partial_data.T
    t_data.reset_index(inplace = True)
    t_data.columns = t_data.iloc[0].tolist()
    t_data.drop([0], inplace = True)
    t_data['country_name'] = country
    t_data.rename(columns = {'Indicator Name' : 'year'}, inplace = True)
    transposed_data = transposed_data.append(t_data)


## change locations of features
ls_column = transposed_data.columns.tolist()
transposed_data = transposed_data[['country_name'] + ls_column[:-1]]

## Null Value Statistics
transposed_data = pd.read_csv('transposed_data.csv')
columns = transposed_data.columns.tolist()
lens = len(transposed_data)
q = PriorityQueue()
valid_columns = []

for column_name in columns:
    q.put((np.round(transposed_data[column_name].isna().sum() / lens, 3), column_name))
    if (transposed_data[column_name].isna().sum() / lens < 0.5):
        valid_columns.append(column_name)
print('The rank of null value rate column:')
while not q.empty():
    print(q.get())

len(valid_columns)

"""# Part I Visulization and Prediction of Demography

##1.1 Visualization of demographic features

### 1.1.1 Population Change
"""

## Overview of demographic transition
world_data = transposed_data[transposed_data['country_name'] == 'World']
female_columns = [column_name for column_name in columns if 'Female population' in column_name]
male_columns = [column_name for column_name in columns if 'Male population' in column_name]
world_data = world_data[['year'] + female_columns + male_columns]

world_data['female_population'] = 0
world_data['male_population'] = 0
for female_column in female_columns:
    world_data['female_population'] = world_data['female_population'] + world_data[female_column]
for male_column in male_columns:
    world_data['male_population'] = world_data['male_population'] + world_data[male_column]
world_data['population'] = world_data['male_population'] + world_data['female_population']

## Plot male and female population

plt.figure(figsize=(12, 6))
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.plot(world_data['year'], world_data[['female_population', "male_population"]])
legends = ['female_population', 'male_population']
font = {'family':'simhei', 'weight': 'normal', 'size': 15}
plt.legend(legends, loc='best', prop=font, labelspacing=1, frameon=True)
plt.xticks(np.arange(1960, 2016, step = 5))
plt.yticks(fontsize=10)
plt.xlabel('Year', fontsize=15)
plt.ylabel('Population', fontsize=15)
plt.title('Male and Female Population', fontsize = 15)

"""### 1.1.2 Growth Rate and Death Rate"""

world_data = transposed_data[transposed_data['country_name'] == 'World']
columns = world_data.columns

# choose the feature we use
birth_rate_feature = 'Birth rate, crude (per 1,000 people)'
death_rate_feature = 'Death rate, crude (per 1,000 people)'

bd_rate = world_data[['year', birth_rate_feature, death_rate_feature]]
bd_rate.columns = ['year', 'birth_rate', 'death_rate']

## plot birth rate and death rate
plt.figure(figsize=(10, 5))
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.plot(bd_rate['year'], bd_rate[['birth_rate', 'death_rate']])
legends = ['birth_rate', 'death_rate']
font = {'family':'simhei', 'weight': 'normal', 'size': 15}
plt.legend(legends, loc='best', prop=font, labelspacing=1, frameon=True)
plt.xticks(np.arange(1960, 2015, step = 5))
plt.yticks(fontsize=10)
plt.xlabel('Year', fontsize=15)
plt.ylabel('Rate (per 1,000 people)', fontsize=15)
plt.title('Birth Rate and Death Rate', fontsize = 15)
plt.show()

## Add continent label to data
world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
continent_label = world[['iso_a3', 'continent']]
continent_label.columns = ['country_code', 'continent']

df_name_code = raw_data[['Country Name', 'Country Code']].drop_duplicates()
df_name_code.columns = ['country_name', 'country_code']
df_transposed = pd.merge(df_name_code, transposed_data, on = 'country_name')
df_transposed = pd.merge(df_transposed, continent_label, on = 'country_code')
df_continent_bd = df_transposed[['year', 'continent', birth_rate_feature, death_rate_feature]]
df_continent_bd = df_continent_bd.groupby(['continent', 'year']).mean().reset_index()
df_continent_bd.columns = ['continent', 'year', 'birth_rate', 'death_rate']

## plot birth rate and death rate change for every continent

# plot birth rate
for continent in df_continent_bd['continent'].unique():
    plot_tmp = df_continent_bd[df_continent_bd['continent'] == continent]
    plt.plot(plot_tmp['year'], plot_tmp[['birth_rate']])
plt.legend(df_continent_bd['continent'].unique(), loc='best')
plt.xlabel('Year', fontsize=15)
plt.ylabel('Birth Rate', fontsize=15)
plt.xticks(np.arange(1960, 2015, step = 5))
plt.yticks(fontsize=10)
plt.title('Birth Rate for Continents')
plt.figure(figsize=(10, 5))
plt.show()

# plot death rate
for continent in df_continent_bd['continent'].unique():
    plot_tmp = df_continent_bd[df_continent_bd['continent'] == continent]
    plt.plot(plot_tmp['year'], plot_tmp[['death_rate']])
plt.legend(df_continent_bd['continent'].unique(), loc='best')
plt.xlabel('Year', fontsize=15)
plt.ylabel('Death Rate', fontsize=15)
plt.xticks(np.arange(1960, 2015, step = 5))
plt.yticks(fontsize=10)
plt.title('Death Rate for Continents')
plt.figure(figsize=(10, 5))
plt.show()

"""### 1.1.3 Population Age Structure"""

## Plot Demographic Pyramid

# define plot function
def plot_demographic_pyramid(year, data):

    # get male and female age
    female_age = data[(data['Country Name'] == 'World') & (data['Indicator Name'].str.contains('Female population'))]
    female_age['age'] = female_age['Indicator Name'].str[-5:]
    male_age = data[(data['Country Name'] == 'World') & (data['Indicator Name'].str.contains('Male population'))]
    male_age['age'] = male_age['Indicator Name'].str[-5:]

    # formalize demographic data
    female_pyramid = female_age[['age', year]]
    female_pyramid.columns = ['age', 'female_population']
    male_pyramid = male_age[['age', year]]
    male_pyramid.columns = ['age', 'male_population']
    demographic_pyramid = pd.merge(male_pyramid, female_pyramid, on = 'age')
    ls_age = demographic_pyramid.age.tolist()
    ls_age[-1] = '80+'
    demographic_pyramid['age'] = ls_age


    x_M = demographic_pyramid['male_population']
    x_F = demographic_pyramid['female_population'] * -1
    y = np.arange(0, 81, 5)
    y_age = [ ]
    for i in range(len(y) - 1):
        lower_bound = y[i]
        upper_bound = y[i] + 4
        y_age.append(str(lower_bound) + '-' + str(upper_bound))
    y_age.append('80+')

    fig = gp.Figure()
    fig.add_trace(gp.Bar(y= y_age, x = x_M, name = 'Male', orientation = 'h'))
    fig.add_trace(gp.Bar(y = y_age, x = x_F, name = 'Female', orientation = 'h'))
    fig.update_layout(title = 'Population Pyramid of World-' + year,
                    title_font_size = 22, barmode = 'relative',
                    bargap = 0.0, bargroupgap = 0,
                    xaxis = dict(tickvals = [-300000000, -200000000, -100000000,
                                            0, 100000000, 200000000, 300000000],
                                    
                                ticktext = ['30M', '20M', '10M', '0', 
                                            '10M', '20M', '30M'],
                                    
                                title = 'Population in Millions',
                                title_font_size = 14) )
    fig.show()

ls_year = ['1975', '1995', '2015']
for year in ls_year:
    plot_demographic_pyramid(year, raw_data)

"""### 1.1.4 Population Distribution"""

## Visualization of Population Distribution Across the World

# define plot function
def plot_pop_distribution(year):

    # get country location from geopandas
    world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
    world.rename(columns = {'name':'country_name', 'iso_a3':'country_code'}, inplace = True)

    # get country population
    columns = transposed_data.columns.tolist()
    female_columns = [column_name for column_name in columns if 'Female population' in column_name]
    male_columns = [column_name for column_name in columns if 'Male population' in column_name]

    # add missing columns
    df = pd.merge(transposed_data, 
                raw_data.rename(columns = {'Country Name':'country_name', 'Country Code':'country_code'})[['country_name','country_code']].drop_duplicates(),
                on = 'country_name')
    country_pop = df[['country_name', 'country_code', 'year'] + female_columns + male_columns]
    country_pop['population'] = 0
    for column in (female_columns + male_columns):
        country_pop['population'] = country_pop['population'] + country_pop[column]
    country_pop = country_pop[country_pop['year'] == year]
    country_pop = country_pop[['country_code', 'population']]

    # merge world location and country population
    merge = pd.merge(country_pop, world, on = 'country_code')
    # merge = pd.merge(country_info, location, on = 'country_name')
    merge = merge.sort_values(by = 'population')
    merge = GeoDataFrame(merge)
    merge.plot(column='population', scheme="quantiles", figsize=(25, 20),legend=True,cmap='coolwarm')
    plt.title('Population Distribution in ' + str(year),fontsize=25)
    plt.show()

ls_year = [1975, 1995, 2015]
for year in ls_year:
    plot_pop_distribution(year)

"""## 1.2 Forecast World Population"""

## Get World Population Information
world_data = transposed_data[transposed_data['country_name'] == 'World']
female_columns = [column_name for column_name in columns if 'Female population' in column_name]
male_columns = [column_name for column_name in columns if 'Male population' in column_name]
world_data = world_data[['year'] + female_columns + male_columns]

world_data['female_population'] = 0
world_data['male_population'] = 0
for female_column in female_columns:
    world_data['female_population'] = world_data['female_population'] + world_data[female_column]
for male_column in male_columns:
    world_data['male_population'] = world_data['male_population'] + world_data[male_column]
world_data['population'] = world_data['male_population'] + world_data['female_population']
df_world = world_data[['year', 'population']]

"""### 1.2.1 Moving Average"""

## Get Rolling Average Prediction

# Let prediction be the average of the past 3 years' population
# Predict Population After 2000
df_rolling = df_world.copy()
df_rolling['rolling_avg'] = df_rolling['population'].rolling(3).mean()
df_rolling['year'] = df_rolling['year'] + 1
df_rolling = df_rolling[['year', 'rolling_avg']]
df_rolling_pred = pd.merge(df_world, df_rolling, on = 'year')
df_rolling_pred = df_rolling_pred[df_rolling_pred['year'] > 2000]
df_rolling_pred

def get_pred_accuracy(df, pred_column):
    tmp_accuracy = df.copy()
    tmp_accuracy['diff'] = abs(tmp_accuracy['population'] - tmp_accuracy[pred_column])
    accuracy = 1 - tmp_accuracy['diff'].sum() / tmp_accuracy['population'].sum()
    bias = tmp_accuracy[pred_column].sum() / tmp_accuracy['population'].sum()
    return accuracy, bias

accuracy, bias = get_pred_accuracy(df_rolling_pred, 'rolling_avg')
print('The bias for rolling average is ' + str(bias.round(3)))
print('The accuracy for rolling average is ' + str(accuracy.round(3)))

"""### 1.2.2 Prediction Based on Trend

We have noticed that there is an obvious trend of population growth. So the moving average method will underestimate population. Based on such assumption, we want to get the increase rate of population and use this rate to predict population.
"""

## Get average increase rate of population growth
df_trend = df_world.copy()
df_join = df_world.copy()
df_join['year'] = df_join['year'] + 2
df_join.columns = ['year', 'added_pop']
df_cal_trend = pd.merge(df_trend, df_join, on = 'year')
df_cal_trend['trend_factor'] = np.sqrt(df_cal_trend['population'] / df_cal_trend['added_pop'])
df_pred_trend = df_cal_trend[['year', 'population', 'trend_factor']]
df_pred_trend

## Get prediction result
df_pred = df_pred_trend.copy()
df_pred['year'] = df_pred['year'] + 1
df_pred['trend_pred'] = df_pred['population'] * df_pred['trend_factor']
df_trend_pred = pd.merge(df_world, df_pred[['year', 'trend_pred']], on = 'year')
df_trend_pred = df_trend_pred[df_trend_pred['year'] > 2000]

accuracy, bias = get_pred_accuracy(df_trend_pred, 'trend_pred')
print('The bias for trend prediction is ' + str(bias.round(5)))
print('The accuracy for trend prediction is ' + str(accuracy.round(5)))

"""### 1.2.3 ARIMA"""

## Test whether the data is stationary

df_test = df_world.copy()
test_result=adfuller(df_test[df_test['year'] < 2000]['population'])

def adfuller_test(population):
    result=adfuller(population)
    labels = ['ADF Test Statistic','p-value','#Lags Used','Number of Observations']
    for value,label in zip(result,labels):
        print(label+' : '+str(value) )

adfuller_test(df_test[df_test['year'] < 2000]['population'])

"""Here P-value is 0.997 which is greater than 0.1, which means data is accepting the null hypothesis, which means data is non-stationary."""

## Get autocorrelation result
autocorrelation_plot(df_test[df_test['year'] < 2000]['population'])

fig = plt.figure(figsize=(12,8))
fig = sm.graphics.tsa.plot_acf(df_test[df_test['year'] < 2000]['population'])

fig = plt.figure(figsize=(12,8))
fig = sm.graphics.tsa.plot_pacf(df_test[df_test['year'] < 2000]['population'])

## Fit ARIMA

model = ARIMA(df_test[df_test['year'] < 2000]['population'],order=(1,1,1))
model = sm.tsa.statespace.SARIMAX(df_test['population'],order=(1, 1, 1))
results = model.fit()
results.summary()

## Use model to predict
df_test['prediction'] = results.predict()
df_arima = df_test[df_test['year'] > 2000]
df_arima.columns = ['year', 'population', 'arima_pred']

accuracy, bias = get_pred_accuracy(df_arima, 'arima_pred')
print('The bias for ARIMA is ' + str(bias.round(5)))
print('The accuracy for ARIMA is ' + str(accuracy.round(5)))

"""### 1.2.4 Prophet"""

## Transform data used for Prophet

df_prophet = df_world.copy()
# df_prophet['year'] = pd.to_datetime(df_prophet['year'])
df_prophet.columns = ['ds', 'y']

# Define model
model = Prophet()

# Fit model
model.fit(df_prophet)

future = df_prophet[df_prophet['ds'] > 2000][['ds']]
forecast = model.predict(future)
forecast['year'] = np.arange(2001,2016)
df_prophet_pred = forecast[['year', 'yhat']]
df_prophet_pred.columns = ['year', 'prophet_pred']

df_prophet_pred = pd.merge(df_world, df_prophet_pred, on = 'year')
df_prophet_pred

accuracy, bias = get_pred_accuracy(df_prophet_pred, 'prophet_pred')
print('The bias for Prophet is ' + str(bias.round(5)))
print('The accuracy for Prophet is ' + str(accuracy.round(5)))

"""## 1.3 Compare Different Predict Methods"""

df_rolling_pred

## Aggregate All Results
accuracy = []
bias = []
ls_df = [df_rolling_pred, df_trend_pred, df_arima, df_prophet_pred]
ls_column = ['rolling_avg', 'trend_pred', 'arima_pred', 'prophet_pred']
for i in range(4):
    a, b = get_pred_accuracy(ls_df[i], ls_column[i])
    accuracy.append(a)
    bias.append(b)
agg_pred = pd.DataFrame({'Method':ls_column, 'Accuracy':accuracy, 'Bias':bias})
agg_pred

"""Compare the accuracy and bias above, we find that prophet can best predict future population, so we use prophet method to predict world and continent population after 2015.

## 1.4 Use Prophet to forecast population after 2015
"""

## Transform data used for Prophet

df_prophet = df_world.copy()
# df_prophet['year'] = pd.to_datetime(df_prophet['year'])
df_prophet.columns = ['ds', 'y']

# Define model
model = Prophet()

# Fit model
model.fit(df_prophet)

future = pd.DataFrame({'ds':np.arange(2016,2031)})
forecast = model.predict(future)
df_prophet_pred = forecast[['ds', 'yhat']]
df_prophet_pred['year'] = np.arange(2016,2031)
df_prophet_pred = df_prophet_pred[['year', 'yhat']]
df_prophet_pred.columns = ['year', 'prophet_pred']

df_prophet_pred

plt.plot(df_world['year'], df_world['population'] / 1000000000, color = 'blue')
plt.plot(df_prophet_pred['year'], df_prophet_pred['prophet_pred'] / 1000000000, color = 'orange')
plt.xlabel('Year', fontsize=15)
plt.ylabel('Population(Billion)', fontsize=15)
plt.xticks(np.arange(1960, 2031, step = 10))
plt.yticks(fontsize=10)
plt.title('Population Prediction')
plt.figure(figsize=(20, 10))
plt.show()



"""# Part 2: Exploring HIV

## 2.0 Introduction and overview:


*   We selected a data set from the world bank with worldwide chronologic HIV data with social and demographic features from 1960 to 2015. The very important and verbose part will be EDA and data wrangling in the first section.



*   In this part, we are trying to find the factors that will affect the the percentage prevalence of HIV for the main labor force, age group 15-49.



*    We would conduct heuristic data mining to extract patterns and also build a classifier for HIV prevalence prediction based on the values of the selected features.

![RS16_iStock-640012070-lpr.jpeg](data:image/jpeg;base64,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)

### 2.1 Import packages and loading data
"""

#import all packages needed
import pandas as pd
import numpy as np; np.random.seed(0)
import seaborn as sns; sns.set_theme()
import matplotlib.pyplot as plt

#making sure we're using the same dataset
#Download data
from google_drive_downloader import GoogleDriveDownloader as gdd
# https://drive.google.com/file/d/1K6EenD5rYjZuvMwH-5g10GlbXPIsYI_n/view?usp=sharing
gdd.download_file_from_google_drive(file_id='1K6EenD5rYjZuvMwH-5g10GlbXPIsYI_n',
                                    dest_path='/content/data.csv')

# https://drive.google.com/file/d/11z2X-yajVr8zL6uIHrudEZDFNqDNRei0/view?usp=sharing
gdd.download_file_from_google_drive(file_id='11z2X-yajVr8zL6uIHrudEZDFNqDNRei0',
                                    dest_path='/content/transposed_data.csv')

df = pd.read_csv('/content/data.csv')
df_trans = pd.read_csv('/content/transposed_data.csv')

"""### 2.2 Simple visualizing the trend of HIV"""

df_world = df_trans[df_trans['country_name'] == 'World']
df_world.head(5)

past_25 = df_world.iloc[30:][['country_name','year',"Prevalence of HIV, total (% of population ages 15-49)",'Prevalence of HIV, male (% ages 15-24)','Prevalence of HIV, female (% ages 15-24)']]
y_total = past_25["Prevalence of HIV, total (% of population ages 15-49)"]
y_male = past_25['Prevalence of HIV, male (% ages 15-24)']
y_female = past_25['Prevalence of HIV, female (% ages 15-24)']
year = past_25['year']

"""**The worldwide trend of HIV prevalance:**"""

plt.plot( year, y_total )
plt.xlabel('year')
plt.ylabel('Prevalence of HIV %')
plt.title('Worldwide Prevalence of HIV (% of population ages 15-49) vs. year')
plt.show()

"""**The difference between gender on the trend of HIV prevalence**:"""

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.plot(year, y_male,'b')
ax.set_title('Male vs. Female: Prevalence of HIV (% of population ages 15-49)')
ax.plot(year, y_female,color='tab:orange')
ax.set_ylabel('HIV %')
plt.show()

"""## 2.1 EDA, Data wrangling and Feature selection for analyzing HIV

### 2.1.1 Having a look at our dataset-- what features do we have? how many na values  are there?

Let's see the structure of the original data.
"""

df.head(5)

"""The original dataset has multiindex: year and country. We want our features to be in the form of columns. In the previous part, we re-organized the dataframe into the following form with features being pivoted:"""

df_trans.head(5)

"""Let's find out what column names do we have!

"""

df.columns

"""Let's see what countries do we have"""

countries = set(df_trans['country_name'])
countries

"""Before doing feature selection, we wanna see what features do we have.This will be good for applying domain knowledge."""

#'Indicator Name'--feature set
arb = df[df['Country Name']== 'Arab World']
for i in arb['Indicator Name']:
  print(i)

features = arb['Indicator Name']

"""By looking at all the features we have, we want to explore what things will possibly affect the prevalance of HIV. Let's take a closer look on the data for our y variable(label) that we are interested in, namely 'Prevalence of HIV, total (% of population ages 15-49)'. As we can see, there are many NA values."""

df[df['Indicator Name'] == 'Prevalence of HIV, total (% of population ages 15-49)']

"""### 2.1.2 Dealing with NA values

The previous part shows we have many NA values for each features across regions and years. We will neglect the columns or the rows with too much missing values using data imputation.
"""

df_trans.head(5)

#there are 14448 data points acrossing countries and years each with 347 features
df_trans.shape

"""features with most NA values:"""

nullvalues = df_trans.isnull().sum().sort_values()
nullvalues.tail(30)

nullvalues.describe()

df_trans.shape

"""try to drop rows with any NA values"""

df_clean = df_trans.dropna(axis= 0)
df_clean.shape

"""Found out can't drop with any NA. Let's focus on the NA values of our labels and drop all rows without labels"""

df_hiv = df_trans.dropna(subset = ['Prevalence of HIV, total (% of population ages 15-49)'])
df_hiv

"""We have 3198 data points with labels:"""

df_hiv.isnull().describe()

"""Remove the columns with over 90% missing data"""

remove_columns = []
for c in df_hiv.columns:
  #total have 3198 rows with y values
  if df_hiv[c].isnull().sum() > 3198*0.1:
    remove_columns.append(c)

print('number of rows to be removed:')
len(remove_columns)

df_hiv_reducefeature = df_hiv.drop(remove_columns, axis=1)
df_hiv_reducefeature

"""Noticed that there are still 113 features left:

### 2.1.3 Further feature selection using correlation matrix
"""

df_hiv_reducefeature.shape

useful_features = df_hiv_reducefeature.columns.to_list()
useful_features.remove('country_name')
useful_features.remove('year')

"""Roughly select features correlated to our y: HIV prevalence"""

corr = df_hiv_reducefeature[useful_features].corr()
ax = sns.heatmap(corr)

"""List out the top 30 negatively correlated features:"""

corr['Prevalence of HIV, total (% of population ages 15-49)'].sort_values(ascending = True).head(30)

"""Plot the top 30 negatively correlated features"""

df_corr = corr.sort_values(by = ['Prevalence of HIV, total (% of population ages 15-49)'])[['Prevalence of HIV, total (% of population ages 15-49)']]
neg = df_corr.head(20)
pos = df_corr.tail(20)

fig, ax = plt.subplots()
ax.barh(neg.index, neg.iloc[:,0])
plt.style.use('fivethirtyeight')
ax.set(xlabel='correaltion', ylabel='features',
       title='Top 20 negative correlated features to Y')
plt.show()

"""The results make sense based on our common sense. Since we are interested in the prevalence of HIV for the age group of 15-49. Survival to 65 is likely to be the most negatively correlated feature because it's not likely that a region with higher HIV prevalence for age15-49 reuslt in a higher survival ratio to age 65. The victims probably can't make it till his/her 65.

The results also indicate a negative correlation for the environmental and social factors like water source(hygine), sanitation facilities, immunization, urban population and life expectancy.
"""

corr['Prevalence of HIV, total (% of population ages 15-49)'].sort_values(ascending = False).head(30)



fig, ax = plt.subplots()
ax.barh(pos.index, pos.iloc[:,0])
plt.style.use('fivethirtyeight')
ax.set(xlabel='correaltion', ylabel='features',
       title='Top 20 positive correlated features to Y')
plt.show()

df_corr.sort_values(by = ['Prevalence of HIV, total (% of population ages 15-49)'], ascending=False).head(30)
remove_features = ['Prevalence of HIV, total (% of population ages 15-49)','Prevalence of HIV, female (% ages 15-24)','Prevalence of HIV, male (% ages 15-24)','Incidence of HIV (% of uninfected population ages 15-49)',
                   "Women's share of population ages 15+ living with HIV (%)"]

"""Noticed that we set out objective label specificly for the age group of 15-49, the first several rows of other age groups' HIV prevalence should be excluded for controlling factors. When doing prediction, we expect we have no other  knowledges of HIV prevalence.

The result indicates a positive correlation between the prevalence of HIV to the motality rate, unemployment rate, birth rate and rural population, etc. We will later select these features for learning.

Let's visualize the most positively and negatively correlated feature, respectively.
"""

sns.set(color_codes=True)
ax = sns.regplot(x="Mortality rate, adult, female (per 1,000 female adults)", y="Prevalence of HIV, total (% of population ages 15-49)", data=df_hiv_reducefeature ,line_kws={'color':'red'})

sns.set(color_codes=True)
ax = sns.regplot(x="Survival to age 65, female (% of cohort)", y="Prevalence of HIV, total (% of population ages 15-49)", data=df_hiv_reducefeature ,line_kws={'color':'red'})

"""We see that the survival rate and motality rate are two perfectly correlated terms thus we should only take one for minimum redundancy.

### 2.1.4 Organizing the data

#### 2.1.4.1 Combining the features

In this sub-part, we will combine all the correlated features to form a feature subset and trying to fill out the missing values.
"""

features_selected = []
features_selected += list(df_corr.head(25).index)
pos_f = list(df_corr.tail(30).index)
for i in remove_features:
   pos_f.remove(i)
features_selected += pos_f
features_selected.remove('Survival to age 65, female (% of cohort)')
features_selected.remove('Survival to age 65, male (% of cohort)')
print('we have roughly selected 50 features')
features_selected

columns = ['country_name','year', 'Prevalence of HIV, total (% of population ages 15-49)'] + features_selected
df_hiv_clean = df_hiv_reducefeature[columns]
df_hiv_clean

df_hiv_clean = df_hiv_clean.dropna()
df_hiv_clean.rename(columns={"Prevalence of HIV, total (% of population ages 15-49)": "y"}, inplace=True)
df_hiv_clean

"""**We will use these 2684 samples each with 48 features for the unsupervised learning and classification part.**

#### 2.1.4.2 KNN inputation for NA rows

Let's using K nearest neighbors to do the data inputation for those NA values. **And store this dataframe as df_hiv_inpute. we will use it in the very last portion of this whole part.**
"""

#next step: select all the rows with NA values

df_hiv_inpute = df_hiv_reducefeature[columns].rename(columns={"Prevalence of HIV, total (% of population ages 15-49)": "y"})
#store the positions of all the NA values
got_NA = df_hiv_inpute.isna().any(axis=1)

df_hiv_inpute[df_hiv_inpute['country_name']== 'Zimbabwe'].tail(5)

"""As seen above, the example of Zimbabwe's feature -- "life expectancy at birth" only misses the data entry of year 2015. So for choosing the imputation method, KNN is a good fit."""

df_hiv_inpute[['country_name','year','y']].isnull().sum()

from sklearn.impute import KNNImputer
imputer = KNNImputer(n_neighbors=2)
x_s = df_hiv_inpute.iloc[:, 3:]
x_s.dtypes

inputed = imputer.fit_transform(x_s)
df_hiv_inpute[features_selected] = inputed
df_hiv_inpute[df_hiv_inpute['country_name']== 'Zimbabwe'].tail(5)

"""Let's check whether the inputed df is filled"""

df_hiv_inpute.isnull().sum()

"""We will select the 514 rows which originally contains NA values and form the dataframe to be used in the application of our classifier later."""

df_hiv_inpute = df_hiv_inpute[got_NA]
df_hiv_inpute

"""### 2.1.5 Defining labels

Before digging into the model, we notice that the label % prevalence is a floating number instead of categorial. we need to decide a threshold for seperating these percentage values(0-1) into two groups with labels '0' and '1'. We first explore the statistics of our y values.
"""

Y = df_hiv_clean['y']
Y.describe()

plt.boxplot(Y)
plt.show()

"""We could see the distribution of the HIV prevalence across region and time are very scattered with lots of high HIV exposure outliers. The mean is descently high because of these high value outliers while the mode is low.

We will adopt the **Low Precision/High Recall**:  we want to reduce the number of false negatives without necessarily reducing the number of false positives, we choose a decision value that has a low value of Precision or a high value of Recall. This is because in our case, we do not want any region with high HIV exposure to be classified as low level exposure without giving much heed to if the region is being wrongfully classified as high level. This is because a region being viewed as high exposure and be further investigated to exclude the true exposure while if a the real high prevalance region is not captured by the model, it is likely that the situation will be neglected with bad consequences.

Thus, we will take the mean as the threshold for labeling.
"""

mean_prevalence = Y.mean()

# 1 for above average score, 0 for below
pd.options.mode.chained_assignment = None
df_hiv_clean['label'] = df_hiv_clean['y'].apply(lambda x: 1 if (x > mean_prevalence) else 0)
print('total number of label "1": ', df_hiv_clean['label'].sum())

"""## 2.2 Unsupervised learning: PCA, Clustering

We can see that some of the features are represented sepereately by sex and age group while they are actually representing the same aspect of this feature. For example, the feature suvival to age *** are seperated into many groups and thus expanding the number of features. In this situation, PCA really comes into handy for dimentionality reduction by extracting the useful information while negating the redundant.

### 2.2.1 Principle component analysis

we wanna know if there are any categorial features in our dataset.
"""

df_hiv_clean.dtypes

features = df_hiv_clean.iloc[:,3:51]
labels = df_hiv_clean['label']

"""Split the data into training and testing sets"""

# scaling
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size= 0.2, random_state = 42)
scl = StandardScaler().fit(x_train)
x_train = scl.transform(x_train)
x_test = scl.transform(x_test)
# find num components to use
pca = PCA(n_components = 48)
x_train_2 = pca.fit_transform(x_train)
# TO DO plot for explained variance
pc_vs_variance = np.cumsum(pca.explained_variance_ratio_)
plt.plot(pc_vs_variance)

explained_variance = pca.explained_variance_ratio_
print(explained_variance)
pca_components = 20

"""**pca2** would be our final PCA machine."""

pca2 = PCA(n_components= pca_components)
pca2.fit(x_train)
x_train = pca2.transform(x_train)
x_test = pca2.transform(x_test)

# visualize 2 components of PCA
x_train_pca = x_train
pca_plot = PCA(n_components=2)
comp = pca_plot.fit_transform(x_train_pca)
data = np.transpose(np.array(comp))
plt.scatter(data[0][0:5000], data[1][0:5000])

"""### 2.2.2 Hierarchical clustering

Let's perform Agglomerative Clustering on our first 2 principle components to see if there are any natural groupings. The code in the next block is refering to https://scikit-learn.org/stable/auto_examples/cluster/plot_digits_linkage.html#sphx-glr-auto-examples-cluster-plot-digits-linkage-py
"""

# Authors: Gael Varoquaux
# License: BSD 3 clause (C) INRIA 2014

from time import time
from scipy import ndimage
from sklearn import manifold, datasets

X = x_train
y = y_train
np.random.seed(0)

n_samples, n_features = X.shape
# Visualize the clustering
def plot_clustering(X_red, labels, title=None):
    x_min, x_max = np.min(X_red, axis=0), np.max(X_red, axis=0)
    X_red = (X_red - x_min) / (x_max - x_min)

    plt.figure(figsize=(6, 4))
    for i in range(X_red.shape[0]):
        plt.text(
            X_red[i, 0],
            X_red[i, 1],
            s = '*',
            color=plt.cm.nipy_spectral(labels[i] / 10.0),
            fontdict={"weight": "bold", "size": 9},
        )

    plt.xticks([])
    plt.yticks([])
    if title is not None:
        plt.title(title, size=17)
    plt.axis("off")
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])

X_red = X
print(X_red.shape)
from sklearn.cluster import AgglomerativeClustering

for linkage in ("ward", "average", "complete", "single"):
    clustering = AgglomerativeClustering(linkage=linkage, n_clusters=5)
    t0 = time()
    clustering.fit(X_red)
    print("%s :\t%.2fs" % (linkage, time() - t0))

    plot_clustering(X_red, clustering.labels_, "%s linkage" % linkage)
    print(clustering.labels_)

plt.show()

"""As we can see, the result is not clear. Clustering is for heuristic data  exploring. If we have already define the label, we should probably directly adopt supervised learning.

## 2.3 Classification

The whole setting of our classifier: our dataset presents the data samples as the feature values of a specific country in a specific year. The feature values thus deliver an aggregate representation of the regional situation in a specific time. By using classification, we are able to obtain a classifier which takes all the feature values to generate the percentage HIV prevalence of age group 15-49 (the main labor force). If the accuracy is promising, we could use it to fill out the missing data for other countries' label or possibly predict a new region's HIV % prevalence based on the features obtained.

### 2.3.1 Model validation using k-fold cross-validation

For this part, we will use k-fold cross-validation on our training set to find out the optimal classifier on our data

#### 2.3.1.1 K-nearest neighbors

consider using KNN, Let's find the optimal k
"""

from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
knn = KNeighborsClassifier()
parameters = {'n_neighbors':[3, 6, 9, 12, 15, 18, 21, 24]}
rf_cv1 = GridSearchCV(knn, parameters)
rf_cv1.fit(x_train, y_train)

rf_cv1.best_params_

"""It turns out that the best alpha is 0, which is equivalent to an ordinary least square method."""

from sklearn.model_selection import cross_val_score
knn1 = KNeighborsClassifier(n_neighbors = 3)
scores = cross_val_score(knn1, x_train, y_train, cv=5, scoring ='accuracy' )
score0 = scores.mean()
score0

"""#### 2.3.1.2 Logistic regression"""

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import mean_squared_error

logistic = LogisticRegression(random_state=0)
scores = cross_val_score(logistic, x_train, y_train, cv=5, scoring ='accuracy' )
score1 = scores.mean()
score1

"""#### 2.3.1.3 Random forest

Let's find out the best hyperparameters for our model
"""

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV
rfc = RandomForestClassifier()

# TODO
parameters = {'n_estimators':[16,32,64,96], 'max_depth':[5,10,15,20,25,30]}
rf_cv = GridSearchCV(rfc, parameters)
rf_cv.fit(x_train, y_train)
rf_cv.get_params

rf_cv.best_params_

rfc = RandomForestClassifier(max_depth=15, n_estimators=96)
scores = cross_val_score(rfc, x_train, y_train, cv=5, scoring ='accuracy' )
score2 = scores.mean()
score2

"""#### 2.3.1.4 Linear Discriminant Analysis"""

from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
lda = LinearDiscriminantAnalysis()
scores = cross_val_score(lda , x_train, y_train, cv=5, scoring ='accuracy' )
score3 = scores.mean()
score3

"""### 2.3.2 Model selection and testing by test set

Choosing method: based on the results of our k-fold cv, we will choose random 
forest as our classifier. Noticed that random forest itself is model using much computation power. Nevertheless, our data set is not very large with only 2684 entries so we will use it anyways.

Let's build a new random forest for our whole training set and see it's performance on the test set.
"""

from sklearn.metrics import accuracy_score
import sklearn
rfc1 = RandomForestClassifier(max_depth=15, n_estimators=96)
rfc1.fit(x_train, y_train)
prediction = rfc1.predict(x_test)

test_accuracy = sklearn.metrics.accuracy_score(prediction,y_test)
print(test_accuracy)

"""The results indicate that the RF classifier is well-built!!! Let's use it for prediction.

### 2.3.3 Further application of our classifier

Recall that from the previous part, we deliberately select those rows with missing values being filled as **df_hiv_inpute**. We did not use this set for unsupervised learning and classification because of its missing values. Here, we assume these data entries are potential cases collected in the future with labels unknown. We wanna use our classifier to predict the prevalence of HIV based on the collected feature variable values.
"""

df_hiv_inpute

"""Similar to the previous part, stick the label based on the percentage value like before."""

pd.options.mode.chained_assignment = None
mean_prevalence = df_hiv_inpute['y'].mean()
df_hiv_inpute['label'] = df_hiv_inpute['y'].apply(lambda x: 1 if (x > mean_prevalence) else 0)
print('total number of label "1": ', df_hiv_inpute['label'].sum())

features2 = df_hiv_inpute.iloc[:,3:51]
labels2 = df_hiv_inpute['label']

"""#### 2.3.3.1 Standardizing and dimentionality reduction"""

scl = StandardScaler().fit(features2)
scaled_x = scl.transform(features2)
#dimensional reduction using the previous PCA model
reduced_x = pca2.transform(scaled_x)

"""#### 2.3.3.2 Using the classifier built for predicting HIV prevalence"""

prediction = rfc1.predict(reduced_x)

test_accuracy = sklearn.metrics.accuracy_score(prediction,labels2)
print(test_accuracy)

"""**The classifier yield a 72% accuracy rate** to predict the potential HIV prevalence based on the 48 features collected. Noted that the many data entry are filled with inputation, thus, shrinking the accuracy to roughly 72%, which is acceptable from our perspective.

# **Module 3: Education**
Education has always been a popular topic in modern social studies. There is a lot of information about school enrolment and literacy rates in the original data. Intuitively, we think that enrollment (education) is related to tuition, hardware equipments, quality of teaching, quality of instructors, etc. But a data-based display would be more convincing. According to the observation of the original data and the explanation of some literatures, we find that the influencing factors of education are also related to the birth rate and death rate of the population, the female pregnancy rate and employment rate. For this module, we will use a linear regression model to analyze factors affecting enrolment (education).

## **3.1 Set Up Module**
Initialize for the module three: Education. These include pySpark installation and drawing module installation, etc.
"""

!pip install geopandas
!pip install -U scikit-learn

import pandas as pd
import numpy as np
import geopandas
from sklearn.impute import KNNImputer 
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder
from sklearn import preprocessing
import seaborn as sns
import matplotlib.pyplot as plt
from google_drive_downloader import GoogleDriveDownloader as gdd

!apt install libkrb5-dev
!wget https://downloads.apache.org/spark/spark-3.1.2/spark-3.1.2-bin-hadoop3.2.tgz
!tar xf spark-3.1.2-bin-hadoop3.2.tgz
!pip install findspark
!pip install sparkmagic
!pip install pyspark
! pip install pyspark --user
! pip install seaborn --user
! pip install plotly --user
! pip install imageio --user
! pip install folium --user

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from pyspark.sql import SparkSession
from pyspark.sql.types import *
import pyspark.sql.functions as F
import os
from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml import Pipeline
from pyspark.ml.feature import PCA
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator

"""## **3.2 Data Wrangling&Cleaning&EDA**
In the original data, we found that the presentation of the data was not suitable for machine learning. So we're going to transform the rendering of the data, which we'll call it transposed_data. After getting the transposed_data, we found that there were many null values in the data. We would delete the lines with more than 70% null values and use KNN to supplement the remaining null values. Secondly, display some data information we need, such as the average, maximum or minimum of the enrollment rate at each stage.

"""

# Upload the file from the google drive
gdd.download_file_from_google_drive(file_id='1K6EenD5rYjZuvMwH-5g10GlbXPIsYI_n',
                                    dest_path='/content/data.csv')

gdd.download_file_from_google_drive(file_id='11z2X-yajVr8zL6uIHrudEZDFNqDNRei0',
                                    dest_path='/content/transposed_data.csv')
data = pd.read_csv('/content/data.csv')
transposed_data = pd.read_csv('/content/transposed_data.csv')

# Display the transposed data
transposed_data

"""### **3.2.1 Data Clean(deal with nan values)**
In transposed_data, we found that there were a large number of null values in the data. This may be because some countries are not collecting data at certain times. To do this, we first decided to delete all rows with more than 70 percent of null values. We can assume that the deleted rows in this section have no significant research significance.
"""

# Display the num value of the transposed_data
# In order to keeping the original data, create a data called trans_df
trans_df = transposed_data
print(transposed_data.isnull().sum())

# Delete all rows with more than 70 percent of null values.
percentage = 70.0 
count_nan = int(((100-percentage)/100)*trans_df.shape[1] + 1)
mod_trans_df = trans_df.dropna(axis = 0, thresh = count_nan)

"""### **3.2.2 Data KNN Imputer**

"""

# Convert country_name to country_code that machine learning can use
le = preprocessing.LabelEncoder()
le.fit(mod_trans_df['country_name'])
le.classes_
country_code = le.fit_transform(mod_trans_df['country_name'])
mod_trans_df['country_code'] = country_code
# Drop the country_name column
mod_trans_drop_country_name_df = mod_trans_df.drop(columns = ['country_name'])

# Define two functions to pick out a optimal k
def rmse_cal(y,y_):
  value = np.sqrt(mean_squared_error(y,y_))
  return value

def Calculate_best_k(dataframe, label):
  RMSE = []
  for k in range(1, 9, 2):
    ip = KNNImputer(n_neighbors=k)
    imputed = ip.fit_transform(dataframe)
    imputed_data = pd.DataFrame(imputed, columns=dataframe.columns)
  
    x = imputed_data.drop(columns=label)
    y = imputed_data[label]

    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
    rf = RandomForestRegressor()
    rf.fit(x_train, y_train)
    preds = rf.predict(x_test)
    rmse = rmse_cal(y_test, preds)
    RMSE.append({'K': k, 'RMSE': rmse}) 
  return RMSE

# Use these functions to calculate k1, k2, k3, it will take too much time, so I recorded them by myself
# k1 = Calculate_best_k(mod_trans_drop_country_name_df, 'School enrollment, primary (% gross)')
# k2 = Calculate_best_k(mod_trans_drop_country_name_df, 'School enrollment, secondary (% gross)')
# k3 = Calculate_best_k(mod_trans_drop_country_name_df, 'School enrollment, tertiary (% gross)')

k1=[{'K': 1, 'RMSE': 5.651755370831432},
    {'K': 3, 'RMSE': 5.252642287554383},
    {'K': 5, 'RMSE': 5.038241549681058},
    {'K': 7, 'RMSE': 5.11761542338636},
    {'K': 9, 'RMSE': 5.381813177211959}]



k2=[{'K': 1, 'RMSE': 6.082474555071997},
    {'K': 3, 'RMSE': 5.124428671224252},
    {'K': 5, 'RMSE': 4.768084185772869},
    {'K': 7, 'RMSE': 4.898667225887287},
    {'K': 9, 'RMSE': 4.444500715033444}]


k3=[{'K': 1, 'RMSE': 2.5999224427304446},
    {'K': 3, 'RMSE': 2.459543895260927},
    {'K': 5, 'RMSE': 2.3419701511190336},
    {'K': 7, 'RMSE': 2.3527869389974074},
    {'K': 9, 'RMSE': 2.24788273372658}]

df1=pd.DataFrame(k1)
plt.figure(1)
plt.title('School enrollment, primary (% gross) RMSE vs K')
plt.scatter(df1['K'], df1['RMSE'])

# Plot for k1, k2, k3
df2=pd.DataFrame(k2)
plt.figure(2)
plt.title('School enrollment, secondary (% gross) RMSE vs K')
plt.scatter(df2['K'], df2['RMSE'])

df3=pd.DataFrame(k3)
plt.figure(3)
plt.title('School enrollment, tertiary (% gross) RMSE vs K')
plt.scatter(df3['K'], df3['RMSE'])

# Use KNN to supplement the missing null value
# For k we will use 5(considering the excuting time)
ip= KNNImputer(n_neighbors=5) 
imputed = ip.fit_transform(mod_trans_drop_country_name_df) 
mod_trans_df_imputed = pd.DataFrame(imputed, columns=mod_trans_drop_country_name_df.columns)

# Check the null values of current dataframe(after imputed): mod_trans_df_imputed
print(mod_trans_df_imputed.shape)
mod_trans_df_imputed.isnull().sum()

"""### **3.2.3 EDA For The Imputed Dataframe**"""

# Calculate the min, max, mean and std of three features
# These features are: 
# School enrollment, primary (% gross)
# School enrollment, secondary (% gross)
# School enrollment, tertiary (% gross)
mtdi=mod_trans_df_imputed
maxes=[mtdi['School enrollment, primary (% gross)'].max(), mtdi['School enrollment, secondary (% gross)'].max(), mtdi['School enrollment, tertiary (% gross)'].max()]
mins=[mtdi['School enrollment, primary (% gross)'].min(), mtdi['School enrollment, secondary (% gross)'].min(), mtdi['School enrollment, tertiary (% gross)'].min()]
stds=[mtdi['School enrollment, primary (% gross)'].std(), mtdi['School enrollment, secondary (% gross)'].std(), mtdi['School enrollment, tertiary (% gross)'].std()]
means=[mtdi['School enrollment, primary (% gross)'].mean(), mtdi['School enrollment, secondary (% gross)'].mean(), mtdi['School enrollment, tertiary (% gross)'].mean()]
print(maxes)
print(mins)
print(stds)
print(means)

"""### **3.2.4 Merge Dataframes**

Some dataframes are used for visualization, so country_name is a required feature for group BY. Some dataframes will be used for machine learning, so features of type string should not appear. To do this, we need to merge to produce different Dataframes for different purposes.
"""

# Use geopandas to extract the names of all the countries
# Name it as country_df
world=geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
country_series=world['name'].unique()
country_data={'country_name': country_series}
country_df=pd.DataFrame(country_data)

# Merge dataframes for visualization
country_for_merge=pd.DataFrame({'country_name': mod_trans_df['country_name'], 'country_code': mod_trans_df['country_code']})
final_transposed_data = pd.merge(country_for_merge, mod_trans_df_imputed, how='right', on='country_code').drop_duplicates()
data_for_visualization_raw = pd.merge(final_transposed_data, country_df, how='right', on='country_name').dropna()
data_for_visualization_raw

"""## **3.3 Find The Most Correlated Features**

### **3.3.1 Gain The Most Correlated Features' Names**

We need to analyze three different enrollment rates in this project. But we will find that there are many features that express almost the same meaning. For example: School enrollment, primary (% gross)' and 'School enrollment, primary, female (% gross)' and 'School enrollment, primary, Male (% gross)' has a correlation of more than 0.9. Therefore, we can define them as features which are of little significance to our research. So we can choose to delete them.
"""

# Delete some columns that useless for ML
drop_col=['School enrollment, primary (% net)',
          'School enrollment, primary, female (% gross)',	'School enrollment, primary, female (% net)', 
          'School enrollment, primary, male (% gross)', 'School enrollment, primary, male (% net)',
          'School enrollment, secondary (% net)',
          'School enrollment, secondary, female (% gross)',	'School enrollment, secondary, female (% net)',
          'School enrollment, secondary, male (% gross)',	'School enrollment, secondary, male (% net)',
          'School enrollment, tertiary, female (% gross)']
cleaned_mod_trans_df_imputed=mod_trans_df_imputed.drop(columns=drop_col)
transposed_df_corr = cleaned_mod_trans_df_imputed.corr()

# Get the most related features of enrollment of primary school
# Call it as s_primary
cor_primary = abs(transposed_df_corr['School enrollment, primary (% gross)'])
s_primary_df = cor_primary[cor_primary>0.3].to_frame().reset_index()
s_primary=s_primary_df['index']

# Get the most related features of enrollment of secondary school
# Call it as s_secondary
cor_secondary = abs(transposed_df_corr['School enrollment, secondary (% gross)'])
s_secondary_df = cor_secondary[cor_secondary>0.3].to_frame().reset_index()
s_secondary=s_secondary_df['index']

# Get the most related features of enrollment of tertiary school
# Call it as s_secondary
cor_tertiary = abs(transposed_df_corr['School enrollment, tertiary (% gross)'])
s_tertiary_df = cor_tertiary[cor_tertiary>0.3].to_frame().reset_index()
s_tertiary=s_tertiary_df['index']

# Use union and intersection function to get uni_features and int_features
s1=pd.Series(s_primary)
s2=pd.Series(s_secondary)
s3=pd.Series(s_tertiary)
# Union these three series
s21=pd.Series(list(set(s1).union(set(s2))))
uni_features=pd.Series(list(set(s21).union(set(s3))))
# intersection these three series
s12=pd.Series(list(set(s1).intersection(set(s2))))
int_features=pd.Series(list(set(s12).intersection(set(s3))))

# The correlated features:
print(s1)
print(s2)
print(s3)

"""### **3.3.2 Display The Heatmap**"""

# Use int_features to get the heatmap
int_features_df=cleaned_mod_trans_df_imputed[int_features.tolist()]
features_corr=int_features_df.corr()

plt.figure(figsize=(10,10))
sns.heatmap(features_corr)
plt.show()

"""## **3.4 PCA**

After using the corr () function, there are still more than 100 features. We see them as high latitude data, so we need to reduce the dimension.

### **3.4.1 Create Labels And Features**
"""

# Use uni_features to do PCA
clean=cleaned_mod_trans_df_imputed[uni_features]
cleaned_mod_trans_df_imputed

# Create the labels and features for primary, sencondary, tertiary enrollment
label_primary = cleaned_mod_trans_df_imputed['School enrollment, primary (% gross)']
features_primary = cleaned_mod_trans_df_imputed[s_primary]

label_secondary = cleaned_mod_trans_df_imputed['School enrollment, secondary (% gross)']
features_secondary = cleaned_mod_trans_df_imputed[s_secondary]

label_tertiary = cleaned_mod_trans_df_imputed['School enrollment, tertiary (% gross)']
features_tertiary = cleaned_mod_trans_df_imputed[s_tertiary]

# define a function to calculate the k(pca components)
def calculate_pca_components(plot_param):
  for i in range(len(plot_param)):
    value=plot_param[i]
    if value>=0.999:
      i=i-1
      print(i)
      return i

"""### **3.4.2 Use PCA To Get The Correlated Features' number And Name**"""

# Use pca to deal with the label which is 'School enrollment, primary (% gross)'
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
x_train1, x_test1, y_train1, y_test1 = train_test_split(features_primary, label_primary, test_size=0.2)
x_std1 = StandardScaler().fit_transform(x_train1)
# find num components to use
pca1 = PCA(n_components=len(x_train1.columns))
x_pca1 = pca1.fit_transform(x_std1)
n1=pca1.components_.shape[0]
# # plot
plot_param1=np.cumsum(pca1.explained_variance_ratio_)
plt.plot(plot_param1)
# plt.show()
print('plot_param1',plot_param1)
len(pca1.explained_variance_ratio_)

calculate_pca_components(plot_param1)
num1=calculate_pca_components(plot_param1)

# print('the best componrts', num)
most_important_primary = [np.abs(pca1.components_[i]).argmax() for i in range(n1)]
initial_feature_names_primary=x_train1.columns.tolist()
# # get the names
most_important_primary_names = [initial_feature_names_primary[most_important_primary[i]] for i in range(n1)]

primary_dict = {'PC{}'.format(i+1): most_important_primary_names[i] for i in range(n1)}
df_primary = pd.DataFrame(sorted(primary_dict.items()))
df_primary.sort_values(by=[0]).reset_index
df_primary[[0,'number']] = df_primary[0].str.split("C", 1, expand=True)
df_primary["number"] = pd.to_numeric(df_primary["number"])
df_primary=df_primary.sort_values(by=['number'])
df_primary=df_primary[df_primary['number']<=num1]
s1_pca=df_primary[1].tolist()
print('series is ', s1_pca)
print(len(s1_pca))

# Use pca to deal with the label which is 'School enrollment, secondary (% gross)'
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
x_train2, x_test2, y_train2, y_test2 = train_test_split(features_secondary, label_secondary, test_size=0.2)
x_std2 = StandardScaler().fit_transform(x_train2)
# find num components to use
pca2 = PCA(n_components=len(x_train2.columns))
x_pca2 = pca2.fit_transform(x_std2)
n2=pca2.components_.shape[0]
# # plot
plot_param2=np.cumsum(pca2.explained_variance_ratio_)
plt.plot(plot_param2)
# plt.show()
print('plot_param2',plot_param2)
len(pca2.explained_variance_ratio_)

calculate_pca_components(plot_param2)
num2=calculate_pca_components(plot_param2)

# print('the best componrts', num)
most_important_secondary = [np.abs(pca2.components_[i]).argmax() for i in range(n2)]
initial_feature_names_secondary=x_train2.columns.tolist()
# # get the names
most_important_secondary_names = [initial_feature_names_secondary[most_important_secondary[i]] for i in range(n2)]

secondary_dict = {'PC{}'.format(i+1): most_important_secondary_names[i] for i in range(n2)}
df_secondary = pd.DataFrame(sorted(secondary_dict.items()))
df_secondary.sort_values(by=[0]).reset_index
df_secondary[[0,'number']] = df_secondary[0].str.split("C", 1, expand=True)
df_secondary["number"] = pd.to_numeric(df_secondary["number"])
df_secondary=df_secondary.sort_values(by=['number'])
df_secondary=df_secondary[df_secondary['number']<=num2]
s2_pca=df_secondary[1].tolist()
print('series is ', s2_pca)
print(len(s2_pca))

# Use pca to deal with the label which is 'School enrollment, tertiary (% gross)'
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
x_train3, x_test3, y_train3, y_test3 = train_test_split(features_tertiary, label_tertiary, test_size=0.2)
x_std3 = StandardScaler().fit_transform(x_train3)
# find num components to use
pca3 = PCA(n_components=len(x_train3.columns))
x_pca3 = pca3.fit_transform(x_std3)
n3=pca3.components_.shape[0]
# # plot
plot_param3=np.cumsum(pca3.explained_variance_ratio_)
plt.plot(plot_param3)
# plt.show()
print('plot_param3',plot_param3)
len(pca3.explained_variance_ratio_)

calculate_pca_components(plot_param3)
num3=calculate_pca_components(plot_param3)

# print('the best componrts', num)
most_important_tertiary = [np.abs(pca3.components_[i]).argmax() for i in range(n3)]
initial_feature_names_tertiary=x_train3.columns.tolist()

# # get the names
most_important_tertiary_names = [initial_feature_names_tertiary[most_important_tertiary[i]] for i in range(n3)]

tertiary_dict = {'PC{}'.format(i+1): most_important_tertiary_names[i] for i in range(n3)}
df_tertiary = pd.DataFrame(sorted(tertiary_dict.items()))
df_tertiary.sort_values(by=[0]).reset_index
df_tertiary[[0,'number']] = df_tertiary[0].str.split("C", 1, expand=True)
df_tertiary["number"] = pd.to_numeric(df_tertiary["number"])
df_tertiary=df_tertiary.sort_values(by=['number'])
df_tertiary=df_tertiary[df_tertiary['number']<=num3]
s3_pca=df_tertiary[1].tolist()
print('series is ', s3_pca)
print(len(s3_pca))

"""## **3.5 Data visualization**

### **3.5.1 School Enrollment For Some Certain country**
"""

def draw_plot(x, primary, secondary, tertiary):
  fig = plt.figure()
  ax = fig.add_axes([0,0,1,1])
  ax.legend(labels=['Primary', 'Secondary', 'Tertiary'])
  ax.bar(x, primary_dv, color = 'b', width = 0.25)
  ax.bar(x + 0.25, secondary_dv, color = 'g', width = 0.25)
  ax.bar(x + 0.5, tertiary_dv, color = 'r', width = 0.25)
  plt.legend(['Primary', 'Secondary', 'Tertiary'],loc=2)
  plt.show()

# United Kingdom, China, France, United States, Russian Federation
uk_dv = transposed_data[transposed_data['country_name']=='United Kingdom']
f_dv = transposed_data[transposed_data['country_name']=='United Kingdom']
us_dv = transposed_data[transposed_data['country_name']=='United Kingdom']
c_dv = transposed_data[transposed_data['country_name']=='United Kingdom']
rf_dv = transposed_data[transposed_data['country_name']=='United Kingdom']

X = uk_dv['year']
primary_dv = uk_dv['School enrollment, primary (% gross)'].tolist()
secondary_dv = uk_dv['School enrollment, secondary (% gross)'].tolist()
tertiary_dv = uk_dv['School enrollment, tertiary (% gross)'].tolist()
draw_plot(X, primary_dv, secondary_dv, tertiary_dv)

X = f_dv['year']
primary_dv = f_dv['School enrollment, primary (% gross)'].tolist()
secondary_dv = f_dv['School enrollment, secondary (% gross)'].tolist()
tertiary_dv = f_dv['School enrollment, tertiary (% gross)'].tolist()
draw_plot(X, primary_dv, secondary_dv, tertiary_dv)

X = us_dv['year']
primary_dv = us_dv['School enrollment, primary (% gross)'].tolist()
secondary_dv = us_dv['School enrollment, secondary (% gross)'].tolist()
tertiary_dv = us_dv['School enrollment, tertiary (% gross)'].tolist()
draw_plot(X, primary_dv, secondary_dv, tertiary_dv)

X = c_dv['year']
primary_dv = c_dv['School enrollment, primary (% gross)'].tolist()
secondary_dv = c_dv['School enrollment, secondary (% gross)'].tolist()
tertiary_dv = c_dv['School enrollment, tertiary (% gross)'].tolist()
draw_plot(X, primary_dv, secondary_dv, tertiary_dv)

X = rf_dv['year']
primary_dv = rf_dv['School enrollment, primary (% gross)'].tolist()
secondary_dv = rf_dv['School enrollment, secondary (% gross)'].tolist()
tertiary_dv = rf_dv['School enrollment, tertiary (% gross)'].tolist()
draw_plot(X, primary_dv, secondary_dv, tertiary_dv)

"""### **3.5.2 School Enrollment For The World**"""

# Display the raw data
data_for_visualization_raw

s1_pca.extend(['country_name', 'year', 'School enrollment, primary (% gross)'])
s2_pca.extend(['country_name', 'year', 'School enrollment, secondary (% gross)'])
s3_pca.extend(['country_name', 'year', 'School enrollment, tertiary (% gross)'])

# primary
primary_dv = data_for_visualization_raw[s1_pca]
primary_dv = primary_dv.loc[:,~primary_dv.columns.duplicated()]
fig, axes = plt.subplots(24,6,figsize=(100,400))
for (country, g), ax in zip(primary_dv.groupby('country_name'), axes.ravel()):
    sns.lineplot(data=g, hue='country_name', x='year', y='School enrollment, primary (% gross)', ax=ax)

secondary_dv = data_for_visualization_raw[s2_pca]
secondary_dv = secondary_dv.loc[:,~secondary_dv.columns.duplicated()]
fig, axes = plt.subplots(24,6,figsize=(100,400))
for (country, g), ax in zip(secondary_dv.groupby('country_name'), axes.ravel()):
    sns.lineplot(data=g, hue='country_name', x='year', y='School enrollment, secondary (% gross)', ax=ax)

tertiary_dv = data_for_visualization_raw[s3_pca]
tertiary_dv = tertiary_dv.loc[:,~tertiary_dv.columns.duplicated()]
fig, axes = plt.subplots(24,6,figsize=(100,400))
for (country, g), ax in zip(tertiary_dv.groupby('country_name'), axes.ravel()):
    sns.lineplot(data=g, hue='country_name', x='year', y='School enrollment, tertiary (% gross)', ax=ax)

"""## **3.6 Linear Regression For The Enrollment Rate**"""

from pyspark.context import SparkContext
from pyspark.sql.session import SparkSession
# sc = SparkContext('local')
sc = SparkContext.getOrCreate()
spark = SparkSession(sc)

data_for_lr=cleaned_mod_trans_df_imputed[uni_features]
data_lf_sdf= spark.createDataFrame(data_for_lr)
data_lf_sdf.show()

full_features=data_for_lr.columns.tolist()
labels=['School enrollment, primary (% gross)', 'School enrollment, secondary (% gross)', 'School enrollment, tertiary (% gross)']
columns_to_use = [c for c in full_features if c not in labels]

from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml import Pipeline

features_useful=VectorAssembler(inputCols = data_for_lr.columns.tolist(), outputCol = "features")
data_modified_sdf = features_useful.transform(data_lf_sdf)
data_modified_sdf.show()

features_label_primary_sdf=data_modified_sdf.select('features', 'School enrollment, primary (% gross)')
train1_sdf, test1_sdf = features_label_primary_sdf.randomSplit([0.8, 0.2], seed=2021)

features_label_secondary_sdf=data_modified_sdf.select('features', 'School enrollment, secondary (% gross)')
train2_sdf, test2_sdf = features_label_secondary_sdf.randomSplit([0.8, 0.2], seed=2021)

features_label_tertiary_sdf=data_modified_sdf.select('features', 'School enrollment, tertiary (% gross)')
train3_sdf, test3_sdf = features_label_tertiary_sdf.randomSplit([0.8, 0.2], seed=2021)

"""### **3.6.1 Linear Regression For School enrollment, primary (% gross)**"""

# for primary
from pyspark.ml.feature import PCA
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator

pca1 = PCA(k=num1, inputCol="features", outputCol="pca1")
pca1_md = pca1.fit(train1_sdf)
trans_train1 = pca1_md.transform(train1_sdf)
trans_test1 = pca1_md.transform(test1_sdf)

lr1 = LinearRegression(featuresCol = 'pca1', labelCol='School enrollment, primary (% gross)')
lr1_md = lr1.fit(trans_train1)
preds_train1 = lr1_md.transform(trans_train1)
preds_test1 = lr1_md.transform(trans_test1)

_evaluator = RegressionEvaluator(predictionCol="prediction", labelCol="School enrollment, primary (% gross)", metricName="rmse")
training_rmse1 = _evaluator.evaluate(preds_train1)
test_rmse1 = _evaluator.evaluate(preds_test1)

dic1={'training rmse is ': training_rmse1, 'test rmse is ': test_rmse1}
dic1

"""### **3.6.2 Linear Regression For School enrollment, secondary (% gross)**"""

# for secondary
from pyspark.ml.feature import PCA
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator

pca2 = PCA(k=num2, inputCol="features", outputCol="pca2")
pca2_md = pca2.fit(train2_sdf)
trans_train2 = pca2_md.transform(train2_sdf)
trans_test2 = pca2_md.transform(test2_sdf)

lr2 = LinearRegression(featuresCol = 'pca2', labelCol='School enrollment, secondary (% gross)')
lr2_md = lr2.fit(trans_train2)
preds_train2 = lr2_md.transform(trans_train2)
preds_test2 = lr2_md.transform(trans_test2)

_evaluator = RegressionEvaluator(predictionCol="prediction", labelCol="School enrollment, secondary (% gross)", metricName="rmse")
training_rmse2 = _evaluator.evaluate(preds_train2)
test_rmse2 = _evaluator.evaluate(preds_test2)

dic2={'training rmse is ': training_rmse2, 'test rmse is ': test_rmse2}
dic2

"""### **3.6.3 Linear Regression For School enrollment, tertiary (% gross)**"""

# for tertiary
from pyspark.ml.feature import PCA
from pyspark.ml.regression import LinearRegression
from pyspark.ml.evaluation import RegressionEvaluator

pca3 = PCA(k=num3, inputCol="features", outputCol="pca3")
pca3_md = pca3.fit(train3_sdf)
trans_train3 = pca3_md.transform(train3_sdf)
trans_test3 = pca3_md.transform(test3_sdf)

lr3 = LinearRegression(featuresCol = 'pca3', labelCol='School enrollment, tertiary (% gross)')
lr3_md = lr3.fit(trans_train3)
preds_train3 = lr3_md.transform(trans_train3)
preds_test3 = lr3_md.transform(trans_test3)

_evaluator = RegressionEvaluator(predictionCol="prediction", labelCol="School enrollment, tertiary (% gross)", metricName="rmse")
training_rmse3 = _evaluator.evaluate(preds_train3)
test_rmse3 = _evaluator.evaluate(preds_test3)

dic3={'training rmse is ': training_rmse3, 'test rmse is ': test_rmse3}
dic3

"""## **3.7 Module 3 Summary**

1. There are many empty values in the original data. But we can still see a very clear trend. In each country, primary schools have the highest enrollment rate, followed by secondary schools and tertiary schools.
2. From the data visualization, it can be found that no matter the primary school enrollment rate, secondary school enrollment rate or tertiary school enrollment rate generally shows an increase with time.
3. Among more than 300 features, the primary school enrollment rate has less relevant features than middle school enrollment rate and higher education enrollment rate. This may have something to do with social security and welfare in various countries.
4. It is concluded (after processing with Corr() function and PCA) that the characteristics most correlated (from strong to weak) with primary school enrolment rate are mortality rate, birth rate, medical expenditure, vaccination rate, and urban population.
5.  It is concluded (after processing with Corr() function and PCA) that the characteristics that are most correlated (from strong to weak) with secondary school enrolment rates are total population, health facilities, mortality, personal health expenditure and vaccination rates.
6. It is concluded (after processing with Corr() function and PCA) that the characteristics most correlated with tertiary school enrolment (from strong to weak) are the total population, health expenditure, mortality, and incidence of diseases such as tuberculosis and non-pregnant women anaemia.
"""